package lu.uni.distributedsystems.gsonrmi.server;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.Socket;
import java.util.Random;
import java.util.logging.Logger;

import com.google.code.gsonrmi.RpcRequest;
import com.google.code.gsonrmi.RpcResponse;
import com.google.code.gsonrmi.server.RpcTarget;
import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import com.google.gson.JsonStreamParser;

/**
 * A handler for a single JSON-RPC server connection.
 * Objects of this class each run in their own separate thread.
 */
public class RpcConnectionHandler extends Thread {

	private Socket socket;
	private RpcTarget rpcTarget;
	private Gson gson;
	private JsonStreamParser in;
	private Writer out;
	private Interceptor interceptor;
	private IPEndpoint remoteIPEndpoint;
	private Random rnd = new Random();
	
	private static Logger logger = Logger.getLogger(RpcConnectionHandler.class.getName());

	/**
	 * Constructs a connection handler for the given socket.
	 * 
	 * @param socket		socket connected to some client
	 * @param rpcTarget		the RpcTarget of the associated JSON-RPC server implementation
	 * @param gson			the Gson object to use throughout request processing
	 * @param interceptor	a request/reply interceptor, or null if none is required
	 * @throws IOException	if there is an issue communicating via the socket
	 */
	public RpcConnectionHandler(Socket socket, RpcTarget rpcTarget, Gson gson, Interceptor interceptor) throws IOException {
		this.socket = socket;
		this.rpcTarget = rpcTarget;
		this.gson = gson;
		this.interceptor = interceptor;
		remoteIPEndpoint = new IPEndpoint(socket.getInetAddress(), socket.getPort());
		in = new JsonStreamParser(new InputStreamReader(socket.getInputStream(), "utf-8"));
		out = new OutputStreamWriter(socket.getOutputStream(), "utf-8");
		setDaemon(true);
	}

	/**
	 * Main loop of this connection handler, performing request handling as follows:
	 * <p>
	 * Receive a JSON-RPC request via the socket connection. Close the
	 * connection in case the current service mode is DISCONNECT_BEFORE_PROCESSING.
	 * Otherwise, forward the request to the interceptor. Either the interceptor
	 * returns a response for that request, or the response is generated by handling the
	 * request (via the RpcTarget specified at construction time). The response is forwarded
	 * to the interceptor. In case the current service mode is DISCONNECT_BEFORE_REPLY,
	 * the connection is closed. Otherwise, the response is sent back via
	 * the socket to the caller.
	 */
	@Override
	public void run() {
		try {
			logger.info("handling connection from: " + remoteIPEndpoint);
			
			// default service mode for a new connection is: RELIABLE
			BaseServer.setServiceMode(remoteIPEndpoint, ServiceMode.RELIABLE);
			
			// main request processing loop
			while (in.hasNext()) {
				// fetch request from the socket
				RpcRequest request = gson.fromJson(in.next(), RpcRequest.class);
				// determine current service mode
				ServiceMode mode = BaseServer.getServiceMode(remoteIPEndpoint);
				
				// in case of RANDOM service behavior, randomly pick how to handle the current request 
				if (mode == ServiceMode.RANDOM) {
					switch (rnd.nextInt(3)) {
					case 0:
						mode = ServiceMode.RELIABLE;
						break;
					case 1:
						mode = ServiceMode.DISCONNECT_BEFORE_PROCESSING;
						break;
					case 2:
						mode = ServiceMode.DISCONNECT_BEFORE_REPLY;
						break;
					}
                    logger.info("handling request: " + gson.toJson(request) + " from host: " + remoteIPEndpoint + " in randomly chosen mode: " + mode);
                }
                else
                {
                    logger.info("handling request: " + gson.toJson(request) + " from host: " + remoteIPEndpoint + " in mode: " + mode);
                }
				
				// simulate the case where a request is not received (and thus not processed)
				if (mode == ServiceMode.DISCONNECT_BEFORE_PROCESSING) {
					throw new IOException("explicit disconnect before processing request");
				}
				
				RpcResponse response = null;
				
				// intercept the request; might return a response to be sent back ...
				if (interceptor != null)
					response = interceptor.interceptRequest(request);

				// ... or null in case the request shall be processed in the normal way 
				if (response == null)
					response = rpcTarget.doInvoke(request);

				// intercept the response
				if (interceptor != null)
					interceptor.interceptResponse(request, response);
				
				// simulate the case where the request has been processed, but the
				// reply could not be sent back
                if (mode == ServiceMode.DISCONNECT_BEFORE_REPLY)
                {
                    throw new IOException("explicit disconnect before reply");
                }
                
                // send back reply
				out.write(gson.toJson(response));
				out.flush();
			}
		}
		catch (IOException e) {
			logger.info("closing connection with: " + remoteIPEndpoint);
			e.printStackTrace();
		}
		catch (JsonParseException e) {
			System.err.println("Error parsing incoming JSON message");
			e.printStackTrace();
		}
		finally {
			try {
				socket.close();
			}
			catch (IOException e) {
			}
		}
	}


}
