using AustinHarris.JsonRpc;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace JSON_RPC_Server
{

    /// <summary>
    /// Utility class exporting a remote interface that allows a client
    /// to determine how JSON-RPC requests should be processed via setting a service mode.
    /// </summary>
    public class ManagementService : JsonRpcService
    {

        private static Dictionary<IPEndPoint, ServiceMode> serviceModes = new Dictionary<IPEndPoint, ServiceMode>();

        /// <summary>
        /// Remotely accessible method that allows to determine how requests from a certain
        /// connection end point will be processed.
        /// Handles JSON-RPC invocations like : {'method':'setModeOfHost', 'params':['192.168.1.100','RELIABLE'],'id':1}
        /// </summary>
        /// <param name="ipAddress">IP address of the client-side connection end point</param>
        /// <param name="port">port number of the client-side connection end point</param>
        /// <param name="mode">mode in which subsequent requests shall be processed</param>
        [JsonRpcMethod]
        public void setModeOfHost(String ipAddress, int port, ServiceMode mode)
        {
            IPEndPoint ipEndPoint = new IPEndPoint(IPAddress.Parse(ipAddress), port);

            Trace.TraceInformation("set mode of host: " + ipEndPoint + " to: " + mode);
            setServiceMode(ipEndPoint, mode);
        }

        /// <summary>
        /// Allows to set the service mode for a certain connection end point, determining
        /// how requests from that connection will be processed.
        /// </summary>
        /// <param name="ipEndPoint">IP address and port number of the client-side connection end point</param>
        /// <param name="mode">mode in which subsequent requests shall be processed</param>
        [MethodImpl(MethodImplOptions.Synchronized)]
        public static void setServiceMode(IPEndPoint ipEndPoint, ServiceMode mode)
        {
            serviceModes[ipEndPoint] = mode;
        }

        /// <summary>
        /// Retrieves the currently selected service mode for the given client-side end point.
        /// In case no service mode has been set explicitly yet, the default mode returned
        /// is RELIABLE.
        /// </summary>
        /// <param name="ipEndPoint"></param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.Synchronized)]
        public static ServiceMode getServiceMode(IPEndPoint ipEndPoint)
        {
            return serviceModes[ipEndPoint];
        }

    }

    /// <summary>
    /// Server-side request interceptor.
    /// An Interceptor allows to intercept incoming JSON-RPC requests
    /// as well as JSON-RPC responses.
    /// </summary>
    public interface Interceptor
    {
        /// <summary>
        /// Intercept an incoming JSON-RPC request before being processed.
        /// </summary>
        /// <param name="request">the incoming JSON-RPC request object</param>
        /// <returns>a response for this request, or null if the response should be generated by handling the request</returns>
        JsonResponse interceptRequest(JsonRequest request);

        /// <summary>
        /// Intercept a response before sending it back to the caller.
        /// </summary>
        /// <param name="request">the request that has been handled</param>
        /// <param name="response">the response that has been generated by handling the request</param>
        void interceptResponse(JsonRequest request, JsonResponse response);
    }

    /// <summary>
    /// A listener for JSON-RPC server connection requests.
    /// Creates a connection listener for each incoming connection request.
    /// Each connection listener created will be executed in a separate thread.
    /// </summary>
    public class SocketListener
    {

        private static string GetLocalIPAddress()
        {
            var host = Dns.GetHostEntry(Dns.GetHostName());
            foreach (var ip in host.AddressList)
            {
                if (ip.AddressFamily == AddressFamily.InterNetwork)
                {
                    return ip.ToString();
                }
            }
            throw new Exception("Local IP Address Not Found!");
        }

        /// <summary>
        /// Main loop of this connection listener. Listens for incoming connection
        /// attempts. Accepts connections and creates an RpcConnectionHandler
        /// to process requests from that connection.
        /// </summary>
        /// <param name="listenPort"></param>
        /// <param name="interceptor"></param>
        public static void start(int listenPort, Interceptor interceptor)
        {
            Object managementService = new JSON_RPC_Server.ManagementService();
            var server = new TcpListener(IPAddress.Parse(GetLocalIPAddress()), listenPort);
            server.Start();
            Trace.TraceInformation("listening for connections at: " + server.LocalEndpoint);
            while (true)
            {
                TcpClient client = server.AcceptTcpClient();
                ClientConnectionHandler clientConnectionHandler = new ClientConnectionHandler(client, interceptor);
                Thread thread = new Thread(new ThreadStart(clientConnectionHandler.handleConnection));

                thread.Start();
            }
        }

        /// <summary>
        /// A handler for a single JSON-RPC server connection.
        /// Objects of this class each run in their own separate thread.
        /// </summary>
        class ClientConnectionHandler
        {

            private TcpClient tcpClient;
            private Interceptor interceptor;
            private Random rnd = new Random();

            /// <summary>
            /// Constructs a connection handler for the given client.
            /// </summary>
            /// <param name="client">client connection</param>
            /// <param name="interceptor">a request/reply interceptor, or null if none is required</param>
            public ClientConnectionHandler(TcpClient client, Interceptor interceptor)
            {
                this.tcpClient = client;
                this.interceptor = interceptor;
            }

            /// <summary>
            /// Main loop of this connection handler, performing request handling as follows:
            /// Receive a JSON-RPC request via the socket connection. Close the connection
            /// in case the current service mode is DISCONNECT_BEFORE_PROCESSING.
            /// Otherwise, forward the request to the interceptor. Either the interceptor
            /// returns a response for that request, or the response is generated by handling 
            /// the request (via the RpcTarget specified at construction time). The response 
            /// is forwarded to the interceptor. In case the current service mode is 
            /// DISCONNECT_BEFORE_REPLY, the connection is closed. Otherwise, the response 
            /// is sent back via the socket to the caller.
            /// </summary>
            public void handleConnection()
            {
                // determine remote socket endpoint
                IPEndPoint remoteEndPoint = ((IPEndPoint)tcpClient.Client.RemoteEndPoint);
                Semaphore sequentialiser = new Semaphore(1, 1);

                try
                {

                    Trace.TraceInformation("handling connection from: " + remoteEndPoint);

                    // default service mode for a new connection is: RELIABLE
                    ManagementService.setServiceMode(remoteEndPoint, ServiceMode.RELIABLE);

                    NetworkStream stream = tcpClient.GetStream();
                    StreamWriter writer = new StreamWriter(stream, new UTF8Encoding(false));
                    StreamReader reader = new StreamReader(stream, new UTF8Encoding(false));
                    JsonSerializer jsonSerializer = new JsonSerializer();

                    // main request processing loop
                    while (true)
                    {
                        JsonRequest jsonRequest = (JsonRequest) jsonSerializer.Deserialize(reader, typeof(JsonRequest));

                        if (jsonRequest == null)
                        {
                            Trace.TraceInformation("Connection from host " + remoteEndPoint + " has been closed.");
                            break;
                        }

                        String requestString = JsonConvert.SerializeObject(jsonRequest);

                        // determine current service mode
                        ServiceMode mode = ManagementService.getServiceMode(remoteEndPoint);

                        // in case of RANDOM service behavior, randomly pick how to handle the current request 
                        if (mode == ServiceMode.RANDOM)
                        {
                            switch (rnd.Next(3))
                            {
                                case 0:
                                    mode = ServiceMode.RELIABLE;
                                    break;
                                case 1:
                                    mode = ServiceMode.DISCONNECT_BEFORE_PROCESSING;
                                    break;
                                case 2:
                                    mode = ServiceMode.DISCONNECT_BEFORE_REPLY;
                                    break;
                            }
                            Trace.TraceInformation("handling request: " + requestString + " in randomly chosen mode: " + mode);
                        }
                        else
                        {
                            Trace.TraceInformation("handling request: " + requestString + " in mode: " + mode);
                        }

                        // simulate the case where a request is not received (and thus not processed)
                        if (mode == ServiceMode.DISCONNECT_BEFORE_PROCESSING)
                        {
                            throw new System.IO.IOException("explicit disconnect before processing request");
                        }

                        JsonResponse response = null;

                        // intercept the request; might return a response to be sent back ...
                        if (interceptor != null)
                            response = interceptor.interceptRequest(jsonRequest);

                        // sequentialise all requests, avoiding any potential conflicts resulting
                        // from concurrent request handling, such as for instance mixing up reply
                        // messages
                        sequentialiser.WaitOne();

                        // process the request in the normal way
                        var rpcResultHandler = new AsyncCallback(
                            state =>
                            {
                                var asyncState = ((JsonRpcStateAsync)state);
                                var result = asyncState.Result;
                                var asyncWriter = ((StreamWriter)asyncState.AsyncState);

                                asyncWriter.WriteLine(result);
                                // original code:
                                // asyncWriter.FlushAsync();
                                // modifed to:
                                asyncWriter.Flush();
                                // signal request handling has finished
                                sequentialiser.Release();
                            });
                        var async = new JsonRpcStateAsync(rpcResultHandler, writer) { JsonRpc = requestString };
                        JsonRpcProcessor.Process(async, writer);

                        // simulate the case where the request has been processed, but the
                        // reply could not be sent back
                        if (mode == ServiceMode.DISCONNECT_BEFORE_REPLY)
                        {
                            throw new System.IO.IOException("explicit disconnect before reply");
                        }
                    }
                }
                catch (System.IO.IOException)
                {
                    Trace.TraceInformation("closing connection with: " + remoteEndPoint);
                }
                catch (Exception e)
                {
                    Trace.TraceError("RPCServer exception " + e);
                }
                finally
                {
                    tcpClient.Close();
                }

            }

        }

    }

}
