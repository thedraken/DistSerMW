using AustinHarris.JsonRpc;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace JSON_RPC_Server
{

    /// <summary>
    /// Utility class exporting a remote interface that allows a client
    /// to determine how JSON-RPC requests should be processed via setting a service mode.
    /// </summary>
    public class ManagementService : JsonRpcService
    {

        private static Dictionary<IPEndPoint, ServiceMode> serviceModes = new Dictionary<IPEndPoint, ServiceMode>();

        /// <summary>
        /// Remotely accessible method that allows to determine how requests from a certain
        /// connection end point will be processed.
        /// Handles JSON-RPC invocations like : {'method':'setModeOfHost', 'params':['192.168.1.100','RELIABLE'],'id':1}
        /// </summary>
        /// <param name="ipAddress">IP address of the client-side connection end point</param>
        /// <param name="port">port number of the client-side connection end point</param>
        /// <param name="mode">mode in which subsequent requests shall be processed</param>
        [JsonRpcMethod]
        public void setModeOfHost(String ipAddress, int port, ServiceMode mode)
        {
            IPEndPoint ipEndPoint = new IPEndPoint(IPAddress.Parse(ipAddress), port);

            Trace.TraceInformation("set mode of host: " + ipEndPoint + " to: " + mode);
            setServiceMode(ipEndPoint, mode);
        }

        /// <summary>
        /// Allows to set the service mode for a certain connection end point, determining
        /// how requests from that connection will be processed.
        /// </summary>
        /// <param name="ipEndPoint">IP address and port number of the client-side connection end point</param>
        /// <param name="mode">mode in which subsequent requests shall be processed</param>
        [MethodImpl(MethodImplOptions.Synchronized)]
        public static void setServiceMode(IPEndPoint ipEndPoint, ServiceMode mode)
        {
            serviceModes[ipEndPoint] = mode;
        }

        /// <summary>
        /// Retrieves the currently selected service mode for the given client-side end point.
        /// In case no service mode has been set explicitly yet, the default mode returned
        /// is RELIABLE.
        /// </summary>
        /// <param name="ipEndPoint"></param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.Synchronized)]
        public static ServiceMode getServiceMode(IPEndPoint ipEndPoint)
        {
            return serviceModes[ipEndPoint];
        }

    }

    /// <summary>
    /// Server-side request interceptor.
    /// An Interceptor allows to intercept incoming JSON-RPC requests
    /// as well as JSON-RPC responses.
    /// </summary>
    public interface Interceptor
    {
        /// <summary>
        /// Intercept an incoming JSON-RPC request before being processed.
        /// </summary>
        /// <param name="request">the incoming JSON-RPC request object</param>
        /// <returns>a response for this request, or null if the response should be generated by handling the request</returns>
        JsonResponse interceptRequest(JsonRequest request);

        /// <summary>
        /// Intercept a response before sending it back to the caller.
        /// </summary>
        /// <param name="request">the request that has been handled</param>
        /// <param name="response">the response that has been generated by handling the request</param>
        void interceptResponse(JsonRequest request, JsonResponse response);
    }

    /// <summary>
    /// A listener for JSON-RPC server connection requests.
    /// Creates a connection listener for each incoming connection request.
    /// Each connection listener created will be executed in a separate thread.
    /// </summary>
    public class SocketListener
    {

        private int listenPort;
        private Interceptor interceptor;

        /// <summary>
        /// Create a socket listener. Listens for incoming connection
        /// attempts. Accepts connections and creates an RpcConnectionHandler
        /// to process requests from that connection.
        /// </summary>
        /// <param name="listenPort"></param>
        /// <param name="interceptor"></param>
        public SocketListener(int listenPort, Interceptor interceptor)
        {
            this.listenPort = listenPort;
            this.interceptor = interceptor;
        }

        /// <summary>
        /// Main loop of this connection listener.
        /// </summary>
        public void start()
        {
            Object managementService = new JSON_RPC_Server.ManagementService();
            var server = new TcpListener(IPAddress.Any, listenPort);
            server.Start();
            Trace.TraceInformation("listening for connections at: " + listenPort);
            while (true)
            {
                TcpClient client = server.AcceptTcpClient();
                ClientConnectionHandler clientConnectionHandler = new ClientConnectionHandler(client, interceptor);
                Thread thread = new Thread(new ThreadStart(clientConnectionHandler.handleConnection));

                thread.Start();
            }
        }

        /// <summary>
        /// A handler for a single JSON-RPC server connection.
        /// Objects of this class each run in their own separate thread.
        /// </summary>
        class ClientConnectionHandler
        {

            private TcpClient tcpClient;
            private Interceptor interceptor;
            private Random rnd = new Random();

            /// <summary>
            /// Constructs a connection handler for the given client.
            /// </summary>
            /// <param name="client">client connection</param>
            /// <param name="interceptor">a request/reply interceptor, or null if none is required</param>
            public ClientConnectionHandler(TcpClient client, Interceptor interceptor)
            {
                this.tcpClient = client;
                this.interceptor = interceptor;
            }

            /// <summary>
            /// Main loop of this connection handler, performing request handling as follows:
            /// Receive a JSON-RPC request via the socket connection. Close the connection
            /// in case the current service mode is DISCONNECT_BEFORE_PROCESSING.
            /// Otherwise, forward the request to the interceptor. Either the interceptor
            /// returns a response for that request, or the response is generated by handling 
            /// the request (via the RpcTarget specified at construction time). The response 
            /// is forwarded to the interceptor. In case the current service mode is 
            /// DISCONNECT_BEFORE_REPLY, the connection is closed. Otherwise, the response 
            /// is sent back via the socket to the caller.
            /// </summary>
            public void handleConnection()
            {
                // determine remote socket endpoint
                IPEndPoint remoteEndPoint = ((IPEndPoint)tcpClient.Client.RemoteEndPoint);
                Semaphore sequentialiser = new Semaphore(0, 1);

                try
                {

                    Trace.TraceInformation("handling connection from: " + remoteEndPoint);

                    // default service mode for a new connection is: RELIABLE
                    ManagementService.setServiceMode(remoteEndPoint, ServiceMode.RELIABLE);

                    NetworkStream stream = tcpClient.GetStream();
                    StreamWriter writer = new StreamWriter(stream, new UTF8Encoding(false));
                    StreamReader reader = new StreamReader(stream, new UTF8Encoding(false));
                    JsonSerializer jsonSerializer = new JsonSerializer();

                    // main request processing loop
                    while (true)
                    {
                        JsonRequest jsonRequest = (JsonRequest) jsonSerializer.Deserialize(reader, typeof(JsonRequest));

                        if (jsonRequest == null)
                        {
                            Trace.TraceInformation("Connection from host " + remoteEndPoint + " has been closed.");
                            break;
                        }

                        String requestString = JsonConvert.SerializeObject(jsonRequest);

                        // determine current service mode
                        ServiceMode mode = ManagementService.getServiceMode(remoteEndPoint);

                        // in case of RANDOM service behavior, randomly pick how to handle the current request 
                        if (mode == ServiceMode.RANDOM)
                        {
                            switch (rnd.Next(3))
                            {
                                case 0:
                                    mode = ServiceMode.RELIABLE;
                                    break;
                                case 1:
                                    mode = ServiceMode.DISCONNECT_BEFORE_PROCESSING;
                                    break;
                                case 2:
                                    mode = ServiceMode.DISCONNECT_BEFORE_REPLY;
                                    break;
                            }
                            Trace.TraceInformation("handling request: " + requestString + " in randomly chosen mode: " + mode);
                        }
                        else
                        {
                            Trace.TraceInformation("handling request: " + requestString + " in mode: " + mode);
                        }

                        // simulate the case where a request is not received (and thus not processed)
                        if (mode == ServiceMode.DISCONNECT_BEFORE_PROCESSING)
                        {
                            Trace.TraceInformation("explicit disconnect before processing request");
                            throw new IOException("explicit disconnect before processing request");
                        }

                        JsonResponse jsonResponse = null;

                        // intercept the request; might return a response to be sent back ...
                        if (interceptor != null)
                            jsonResponse = interceptor.interceptRequest(jsonRequest);

                        // ... or null in case the request shall be processed in the normal way 
                        if (jsonResponse == null)
                        {
                            // process the request in the normal way
                            var rpcResultHandler = new AsyncCallback(
                                state =>
                                {
                                    var asyncState = ((JsonRpcStateAsync)state);
                                    var result = asyncState.Result;
                                    var asyncWriter = ((StreamWriter)asyncState.AsyncState);

                                    // create response from result that the handler returned
                                    jsonResponse = JsonConvert.DeserializeObject<JsonResponse>(result);

                                    // signal request handling has finished
                                    sequentialiser.Release();
                                });
                            var async = new JsonRpcStateAsync(rpcResultHandler, writer) { JsonRpc = requestString };
                            JsonRpcProcessor.Process(async, writer);

                            // sequentialise all requests, avoiding any potential conflicts resulting
                            // from concurrent request handling, such as for instance mixing up reply
                            // messages; wait for request to be completed
                            sequentialiser.WaitOne();
                        }

                        // intercept the response (even in case it was a stored response
                        // returned by the request interceptor)
                        if (interceptor != null)
                            interceptor.interceptResponse(jsonRequest, jsonResponse);

                        // simulate the case where the request has been processed, but the
                        // reply could not be sent back
                        if (mode == ServiceMode.DISCONNECT_BEFORE_REPLY)
                        {
                            Trace.TraceInformation("explicit disconnect before sending reply");
                            throw new IOException("explicit disconnect before sending reply");
                        }

                        // send back reply
                        String responseString = JsonConvert.SerializeObject(jsonResponse);

                        writer.Write(responseString);
                        writer.Flush();
                    }
                }
                catch (IOException)
                {
                    Trace.TraceInformation("closing connection with: " + remoteEndPoint);
                }
                catch (Exception e)
                {
                    Trace.TraceError("RPCServer exception " + e);
                }
                finally
                {
                    tcpClient.Close();
                }

            }

        }

    }

}
